<!doctype html>

<html>
   <body>
      <canvas width = "800" height = "600" id = "gl-canvas">
        Sorry; your web browser does not support HTML5's canvas element.
      </canvas>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js" type="text/javascript"></script>
      <script>
         /**
          * This function initialises GL and the viewport.
          */
          function glInit() {
            // Initialise and clear viewport
            gl.clearColor(0.1, 0.1, 0.1, 0.9);
            gl.clearDepth(1.0);
            gl.viewport(0.0, 0.0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
         }

         /**
          * This function draws an object using the supplied shader program
          * 
          * @param   bufferObject   An object returned by initObject
          * @param   shaderprogram  a shader program returned by createProgram
          */
         function drawObject(bufferObject, shaderprogram) {
            gl.useProgram(shaderprogram);

            let vertex_buffer = bufferObject.vertex_buffer;
            let color_buffer = bufferObject.color_buffer;
            let normal_buffer = bufferObject.normal_buffer;
            let tex_buffer = bufferObject.tex_buffer;
            let centroid_buffer = bufferObject.centroid_buffer;
            let index_buffer = bufferObject.index_buffer;
            let number = bufferObject.numVertices;

            // Bind vertex buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
            let aPosition = gl.getAttribLocation(shaderprogram, "aPosition");
            if (aPosition !== -1) {
                gl.vertexAttribPointer(aPosition, 4, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(aPosition);
            }

            // Bind color buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
            let aColor = gl.getAttribLocation(shaderprogram, "aColor");
            if (aColor !== -1) {
                gl.vertexAttribPointer(aColor, 4, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(aColor);
            }

            // Bind normal buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, normal_buffer);
            let aNormal = gl.getAttribLocation(shaderprogram, "aNormal");
            if (aNormal !== -1) {
                gl.vertexAttribPointer(aNormal, 4, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(aNormal);
            }

            // Bind texture coordinate buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, tex_buffer);
            let aTexCoord = gl.getAttribLocation(shaderprogram, "aTexCoord");
            if (aTexCoord !== -1) {
                gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(aTexCoord);
            }

            // Add this for centroids
            gl.bindBuffer(gl.ARRAY_BUFFER, centroid_buffer);
            let aCentroid = gl.getAttribLocation(shaderprogram, "aCentroid");
            if (aCentroid !== -1) {
                gl.vertexAttribPointer(aCentroid, 4, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(aCentroid);
            }

            // Bind index buffer and draw
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
            gl.drawElements(gl.TRIANGLES, number, gl.UNSIGNED_SHORT, 0);
         }

         /**
          * Here we initialise an object. It uploads all its arrays to the GPU
          * and records the references to each. We can then pass this object to drawObject
          * which will bind the arrays
          * 
          * @param   object         An object containing arrays for vertices, colors, normals, texcoords, and indices
          * @param   shaderprogram  a shader program returned by createProgram
          */
        function initObject(object, shaderprogram) {
            gl.useProgram(shaderprogram);

            // Since all the arrays come in the form of 2D matrix objects, we need to flatten them
            let vertices = object.vertices.flat();
            let colors = object.colors.flat();
            let indices = object.indices.flat();
            let normals = object.normals.flat();
            let texcoords = object.texcoords.flat();
            
            // Calculate centroids for each triangle for flat shading with point light
            let centroids = calculateCentroids(vertices, indices);
            
            // Create and store data into vertex buffer
            let vertex_buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            // Create and store data into color buffer
            let color_buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

            // Create and store data into normal buffer
            let normal_buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normal_buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

            // Create and store texture coordinates buffer
            let tex_buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, tex_buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
            
            // Add centroid buffer
            let centroid_buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, centroid_buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(centroids), gl.STATIC_DRAW);

            // Create and store data into index buffer
            let index_buffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            return { 
                vertex_buffer: vertex_buffer,
                color_buffer: color_buffer,
                normal_buffer: normal_buffer,
                tex_buffer: tex_buffer,
                centroid_buffer: centroid_buffer,
                index_buffer: index_buffer,
                numVertices: indices.length 
            };
        }

         /**
          * This function compiles the supplied vertex and fragment shaders into a program
          * 
          * @param   vertCode  Vertex shader code, written in GLSL
          * @param   fragCode  Fragment shader code, written in GLSL
          * 
          * @returns    Shader program
          */
         function createProgram(vertCode, fragCode) {
            // Compile and upload shader programs
            let vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, vertCode);
            gl.compileShader(vertShader);

            // Check for compilation errors
            if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
               console.error('Vertex shader compilation error: ' + gl.getShaderInfoLog(vertShader));
            }

            let fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, fragCode);
            gl.compileShader(fragShader);

            // Check for compilation errors
            if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
               console.error('Fragment shader compilation error: ' + gl.getShaderInfoLog(fragShader));
            }

            let shaderprogram = gl.createProgram();
            gl.attachShader(shaderprogram, vertShader);
            gl.attachShader(shaderprogram, fragShader);
            gl.linkProgram(shaderprogram);

            // Check for linking errors
            if (!gl.getProgramParameter(shaderprogram, gl.LINK_STATUS)) {
               console.error('Shader program linking error: ' + gl.getProgramInfoLog(shaderprogram));
            }

            gl.useProgram(shaderprogram);

            return shaderprogram;
         }

         /**
          * Calculates the centroid of each triangle for flat shading with point light source
          * @param {Array} vertices - Flattened array of vertex positions
          * @param {Array} indices - Array of triangle indices
          * @returns {Array} - Flattened array of centroids for each vertex in each triangle
          */
         function calculateCentroids(vertices, indices) {
            // For flat shading with a point light source, we:
            // 1. Calculate the centroid of each triangle
            // 2. Assign the same centroid to all three vertices of that triangle
            
            let centroids = [];
            
            // Process indices in triplets (each triplet defines one triangle)
            for (let i = 0; i < indices.length; i += 3) {
                // Get the three vertex indices for this triangle
                const idx1 = indices[i];
                const idx2 = indices[i+1];
                const idx3 = indices[i+2];
                
                // Get the actual vertex positions
                // Multiply by 4 because each vertex has 4 components (x,y,z,w)
                const v1 = [
                    vertices[idx1*4], 
                    vertices[idx1*4+1], 
                    vertices[idx1*4+2]
                ];
                
                const v2 = [
                    vertices[idx2*4], 
                    vertices[idx2*4+1], 
                    vertices[idx2*4+2]
                ];
                
                const v3 = [
                    vertices[idx3*4], 
                    vertices[idx3*4+1], 
                    vertices[idx3*4+2]
                ];
                
                // Calculate centroid of the triangle
                const centroidX = (v1[0] + v2[0] + v3[0]) / 3;
                const centroidY = (v1[1] + v2[1] + v3[1]) / 3;
                const centroidZ = (v1[2] + v2[2] + v3[2]) / 3;
                
                // Store the same centroid for each vertex of this triangle
                // This is crucial for flat shading - all vertices of the same face
                // need to have the same centroid value
                centroids.push(centroidX, centroidY, centroidZ, 1.0); // First vertex
                centroids.push(centroidX, centroidY, centroidZ, 1.0); // Second vertex
                centroids.push(centroidX, centroidY, centroidZ, 1.0); // Third vertex
            }
            
            return centroids;
         }

         /**
          * Calculate a normal vector for a triangle face
          * @param {Array} v1 - First vertex of the triangle
          * @param {Array} v2 - Second vertex of the triangle
          * @param {Array} v3 - Third vertex of the triangle
          * @returns {Array} - Normalized normal vector [x, y, z, 0]
          */
         function calculateFaceNormal(v1, v2, v3) {
            // Create vectors from vertices
            const vec1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
            const vec2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
            
            // Calculate cross product
            const normal = [
                vec1[1] * vec2[2] - vec1[2] * vec2[1],
                vec1[2] * vec2[0] - vec1[0] * vec2[2],
                vec1[0] * vec2[1] - vec1[1] * vec2[0]
            ];
            
            // Normalize the vector
            const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
            
            if (length > 0) {
                normal[0] /= length;
                normal[1] /= length;
                normal[2] /= length;
            }
            
            // Return as vec4 with w=0 (direction vector)
            return [normal[0], normal[1], normal[2], 0];
         }
      </script>
      <script>
         /**
          * Create a house shape with 8 faces
          * 
          * @returns    object consisting of vertices, colors, normals, texcoords, and indices
          */
         function house() {
            // Parameters for the house
            const width = 0.8;
            const length = 1.0;
            const height = 0.6;
            const roofHeight = 0.4;
            const w2 = width/2;
            const l2 = length/2;
            
            // We'll duplicate vertices to allow different texture coordinates per face
            // First define the basic positions that will be reused
            const positions = [
                // Base/floor vertices (y = -height/2)
                [-w2, -height/2, -l2],  // 0: front-left
                [w2, -height/2, -l2],   // 1: front-right
                [w2, -height/2, l2],    // 2: back-right
                [-w2, -height/2, l2],   // 3: back-left
                
                // Top of walls (y = height/2)
                [-w2, height/2, -l2],   // 4: front-left-top
                [w2, height/2, -l2],    // 5: front-right-top
                [w2, height/2, l2],     // 6: back-right-top
                [-w2, height/2, l2],    // 7: back-left-top
                
                // Roof peak
                [0, height/2 + roofHeight, 0]  // 8: roof peak
            ];
            
            // Now create our actual vertices, normals, and texture coordinates arrays
            let vertices = [];
            let normals = [];
            let texcoords = [];
            let indices = [];
            let colors = [];
            
            // Function to add a triangle with proper texture coordinates
            function addTriangle(a, b, c, na, nb, nc, ta, tb, tc) {
                // Add vertices
                vertices.push(
                    [positions[a][0], positions[a][1], positions[a][2], 1],
                    [positions[b][0], positions[b][1], positions[b][2], 1],
                    [positions[c][0], positions[c][1], positions[c][2], 1]
                );
                
                // Add normals (calculated for each face)
                const normal = calculateFaceNormal(positions[a], positions[b], positions[c]);
                normals.push(normal, normal, normal);
                
                // Add texture coordinates
                texcoords.push(ta, tb, tc);
                
                // Add colors (white)
                colors.push(
                    [1.0, 1.0, 1.0, 1.0],
                    [1.0, 1.0, 1.0, 1.0],
                    [1.0, 1.0, 1.0, 1.0]
                );
                
                // Add indices (sequential since we're redefining vertices for each face)
                const idx = vertices.length - 3;
                indices.push([idx, idx+1, idx+2]);
            }
            
            // Floor (2 triangles)
            addTriangle(0, 1, 2, 
                        [0,-1,0], [0,-1,0], [0,-1,0], 
                        [0.0, 0.0], [1.0, 0.0], [1.0, 1.0]);
            addTriangle(0, 2, 3, 
                        [0,-1,0], [0,-1,0], [0,-1,0], 
                        [0.0, 0.0], [1.0, 1.0], [0.0, 1.0]);
            
            // Front wall (2 triangles)
            addTriangle(0, 4, 5, 
                        [0,0,-1], [0,0,-1], [0,0,-1], 
                        [0.0, 0.0], [0.0, 1.0], [1.0, 1.0]);
            addTriangle(0, 5, 1, 
                        [0,0,-1], [0,0,-1], [0,0,-1], 
                        [0.0, 0.0], [1.0, 1.0], [1.0, 0.0]);
            
            // Right wall (2 triangles)
            addTriangle(1, 5, 6, 
                        [1,0,0], [1,0,0], [1,0,0], 
                        [0.0, 0.0], [0.0, 1.0], [1.0, 1.0]);
            addTriangle(1, 6, 2, 
                        [1,0,0], [1,0,0], [1,0,0], 
                        [0.0, 0.0], [1.0, 1.0], [1.0, 0.0]);
            
            // Back wall (2 triangles)
            addTriangle(2, 6, 7, 
                        [0,0,1], [0,0,1], [0,0,1], 
                        [0.0, 0.0], [0.0, 1.0], [1.0, 1.0]);
            addTriangle(2, 7, 3, 
                        [0,0,1], [0,0,1], [0,0,1], 
                        [0.0, 0.0], [1.0, 1.0], [1.0, 0.0]);
            
            // Left wall (2 triangles)
            addTriangle(3, 7, 4, 
                        [-1,0,0], [-1,0,0], [-1,0,0], 
                        [0.0, 0.0], [0.0, 1.0], [1.0, 1.0]);
            addTriangle(3, 4, 0, 
                        [-1,0,0], [-1,0,0], [-1,0,0], 
                        [0.0, 0.0], [1.0, 1.0], [1.0, 0.0]);
            
            // Roof triangles
            // Front roof
            addTriangle(4, 8, 5, 
                        [0,0.5,-0.5], [0,0.5,-0.5], [0,0.5,-0.5], 
                        [0.0, 1.0], [0.5, 0.0], [1.0, 1.0]);
            
            // Right roof
            addTriangle(5, 8, 6, 
                        [0.5,0.5,0], [0.5,0.5,0], [0.5,0.5,0], 
                        [0.0, 1.0], [0.5, 0.0], [1.0, 1.0]);
            
            // Back roof
            addTriangle(6, 8, 7, 
                        [0,0.5,0.5], [0,0.5,0.5], [0,0.5,0.5], 
                        [0.0, 1.0], [0.5, 0.0], [1.0, 1.0]);
            
            // Left roof
            addTriangle(7, 8, 4, 
                        [-0.5,0.5,0], [-0.5,0.5,0], [-0.5,0.5,0], 
                        [0.0, 1.0], [0.5, 0.0], [1.0, 1.0]);
            
            return {
                vertices: vertices,
                colors: colors,
                indices: indices,
                normals: normals,
                texcoords: texcoords
            };
         }

        function ground() {
            // Define a large flat ground plane
            const size = 4.0;  // Size of the ground plane
            
            // Define vertices (a simple quad)
            let vertices = [
                [-size, -0.5, -size, 1],  // 0: front-left
                [size, -0.5, -size, 1],   // 1: front-right
                [size, -0.5, size, 1],    // 2: back-right
                [-size, -0.5, size, 1]    // 3: back-left
            ];
            
            // Define triangles
            let indices = [
                [0, 1, 2],  // First triangle
                [0, 2, 3]   // Second triangle
            ];
            
            // Define colors (white to let texture show fully)
            let colors = [
                [1.0, 1.0, 1.0, 1.0],
                [1.0, 1.0, 1.0, 1.0],
                [1.0, 1.0, 1.0, 1.0],
                [1.0, 1.0, 1.0, 1.0]
            ];
            
            // Define normals (pointing up)
            let normals = [
                [0, 1, 0, 0],
                [0, 1, 0, 0],
                [0, 1, 0, 0],
                [0, 1, 0, 0]
            ];
            
            // Define texture coordinates (tiled to make grass look better)
            let texcoords = [
                [0.0, 0.0],
                [4.0, 0.0],  // Repeat texture 4 times in X direction
                [4.0, 4.0],  // Repeat texture 4 times in both directions
                [0.0, 4.0]   // Repeat texture 4 times in Z direction
            ];
            
            return {
                vertices: vertices,
                colors: colors,
                indices: indices,
                normals: normals,
                texcoords: texcoords
            };
        }

        function path() {
            // Define a simple path from the edge 
            const pathWidth = 0.5;
            const pathLength = 3.0;
            
            // Define vertices for a path starting from front (z-) direction
            // Set y-coordinate slightly above ground to prevent z-fighting
            let vertices = [
                // Left edge of path
                [-pathWidth/2, -0.49, -pathLength, 1],     // 0: far left
                [-pathWidth/2, -0.49, 0, 1],              // 1: near left
                
                // Right edge of path
                [pathWidth/2, -0.49, 0, 1],               // 2: near right
                [pathWidth/2, -0.49, -pathLength, 1]      // 3: far right
            ];
            
            // Define triangles
            let indices = [
                [0, 1, 2],  // First triangle
                [0, 2, 3]   // Second triangle
            ];
            
            // Define colors (white to let texture show fully)
            let colors = [
                [1.0, 1.0, 1.0, 1.0], // far left
                [1.0, 1.0, 1.0, 1.0], // near left
                [1.0, 1.0, 1.0, 1.0], // near right
                [1.0, 1.0, 1.0, 1.0]  // far right
            ];
            
            // Define normals (pointing up)
            let normals = [
                [0, 1, 0, 0], // far left
                [0, 1, 0, 0], // near left
                [0, 1, 0, 0], // near right
                [0, 1, 0, 0]  // far right
            ];
            
            // Define texture coordinates
            // Will repeat texture along the length of the path
            let texcoords = [
                [0.0, 0.0],  // far left
                [0.0, 3.0],  // near left (repeat texture 3 times along length)
                [1.0, 3.0],  // near right
                [1.0, 0.0]   // far right
            ];
            
            return {
                vertices: vertices,
                colors: colors,
                indices: indices,
                normals: normals,
                texcoords: texcoords
            };
        }

        function curvedPath() {
            const segments = 7;           
            const pathWidth = 0.3;        
            const pathLength = 0.6;        
            const curveAmount = 0.3;      
            const startDistance = -4.0;    
            
            let vertices = [];
            let colors = [];
            let normals = [];
            let texcoords = [];
            let indices = [];
            
            let currentAngle = 0;
            let lastX = 0;
            let lastZ = startDistance; 
            
            for (let i = 0; i < segments; i++) {
                // Calculate new segment angle (gradually curving)
                currentAngle += curveAmount * (Math.sin(i/segments * Math.PI)); // Sine curve for natural path
                
                // Calculate next position based on previous segment
                let nextX = lastX + pathLength * Math.sin(currentAngle);
                let nextZ = lastZ + pathLength * Math.cos(currentAngle);
                
                // // Stop adding segments if we get too close to the house (approximately at z=-0.5)
                // if (nextZ > -0.6) {
                //     break;
                // }
                
                // Define four corners of this path segment
                let v0 = vertices.length / 4; // Number of vertices 
                
                // Add vertices for this segment
                vertices.push(
                    lastX - pathWidth/2 * Math.cos(currentAngle), -0.49, lastZ + pathWidth/2 * Math.sin(currentAngle), 1,
                    lastX + pathWidth/2 * Math.cos(currentAngle), -0.49, lastZ - pathWidth/2 * Math.sin(currentAngle), 1,
                    nextX + pathWidth/2 * Math.cos(currentAngle), -0.49, nextZ - pathWidth/2 * Math.sin(currentAngle), 1,
                    nextX - pathWidth/2 * Math.cos(currentAngle), -0.49, nextZ + pathWidth/2 * Math.sin(currentAngle), 1
                );
                
                // Add colors
                for (let j = 0; j < 4; j++) {
                    colors.push(1.0, 1.0, 1.0, 1.0);
                    normals.push(0, 1, 0, 0);
                }
                
                // Add texture coordinates
                texcoords.push(
                    0.0, i,
                    1.0, i,
                    1.0, i+1,
                    0.0, i+1
                );
                
                // Add triangles (two per segment)
                indices.push(
                    v0, v0+1, v0+2,
                    v0, v0+2, v0+3
                );
                
                // Update for next segment
                lastX = nextX;
                lastZ = nextZ;
            }
            
            return {
                vertices: vertices,
                colors: colors,
                indices: indices, 
                normals: normals,
                texcoords: texcoords
            };
        }

        function treeTrunk() {
            // Tree trunk parameters
            const trunkHeight = 0.6;
            const trunkRadius = 0.1;
            const segments = 8;
            
            let vertices = [];
            let colors = [];
            let normals = [];
            let texcoords = [];
            let indices = [];
            
            // Create the tree trunk (cylinder)
            const trunkBottomY = -0.5; // Position at ground level
            
            // Create the trunk vertices
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = trunkRadius * Math.cos(angle);
                const z = trunkRadius * Math.sin(angle);
                
                // Bottom vertex
                vertices.push([x, trunkBottomY, z, 1]);
                colors.push([0.6, 0.4, 0.2, 1.0]); // Brown for trunk
                normals.push([x, 0, z, 0]); // Normal pointing outward
                texcoords.push([i / segments, 0]);
                
                // Top vertex
                vertices.push([x, trunkBottomY + trunkHeight, z, 1]);
                colors.push([0.6, 0.4, 0.2, 1.0]); // Brown for trunk
                normals.push([x, 0, z, 0]); // Normal pointing outward
                texcoords.push([i / segments, 1]);
            }
            
            // Create trunk indices (triangles)
            for (let i = 0; i < segments; i++) {
                const idx = i * 2;
                
                // First triangle
                indices.push([idx, idx + 1, idx + 2]);
                
                // Second triangle
                indices.push([idx + 1, idx + 3, idx + 2]);
            }
            
            return {
                vertices: vertices,
                colors: colors,
                indices: indices,
                normals: normals,
                texcoords: texcoords
            };
        }

        function treeCrown() {
            // Crown parameters
            const trunkHeight = 0.6;
            const crownHeight = 0.8;
            const crownRadius = 0.4;
            const segments = 8;
            
            let vertices = [];
            let colors = [];
            let normals = [];
            let texcoords = [];
            let indices = [];
            
            // Create the crown (cone)
            const trunkBottomY = -0.5; // Same as in trunk function
            const crownBaseY = trunkBottomY + trunkHeight;
            const crownTopY = crownBaseY + crownHeight;
            
            // Crown base center
            const crownBaseCenterIdx = vertices.length;
            vertices.push([0, crownBaseY, 0, 1]);
            colors.push([0.0, 0.8, 0.0, 1.0]); // Green for crown
            normals.push([0, -1, 0, 0]); // Normal pointing down
            texcoords.push([0.5, 0.5]);
            
            // Crown top point
            const crownTopIdx = vertices.length;
            vertices.push([0, crownTopY, 0, 1]);
            colors.push([0.0, 0.8, 0.0, 1.0]); // Green for crown
            normals.push([0, 1, 0, 0]); // Normal pointing up
            texcoords.push([0.5, 0.5]);
            
            // Crown base circle
            const crownBaseStartIdx = vertices.length;
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = crownRadius * Math.cos(angle);
                const z = crownRadius * Math.sin(angle);
                
                // Base circle vertex
                vertices.push([x, crownBaseY, z, 1]);
                colors.push([0.0, 0.8, 0.0, 1.0]); // Green for crown
                
                // Calculate normal for cone surface
                const nx = x;
                const nz = z;
                const normalLength = Math.sqrt(nx*nx + crownHeight*crownHeight + nz*nz);
                normals.push([nx/normalLength, crownHeight/normalLength, nz/normalLength, 0]);
                
                // texture coordinates for the leaves to wrap around the cone 
                // This creates a circular pattern
                texcoords.push([i / segments, 0]);
            }
            
            // Create crown side triangles
            for (let i = 0; i < segments; i++) {
                const idx = crownBaseStartIdx + i;
                
                // Triangle from base to top
                indices.push([idx, idx + 1, crownTopIdx]);
                
                // Triangle for base circle (closing the bottom of the cone)
                indices.push([crownBaseCenterIdx, idx + 1, idx]);
            }
            
            return {
                vertices: vertices,
                colors: colors,
                indices: indices,
                normals: normals,
                texcoords: texcoords
            };
        }
      </script>

      <script>
         // GLSL shader code
         const vertCode = `
            attribute vec4 aPosition;
            attribute vec4 aColor;
            attribute vec4 aNormal;      // FACE normal here 
            attribute vec2 aTexCoord;
            attribute vec4 aCentroid;    // Triangle centroid

            uniform mat4 uModelMatrix;
            uniform mat4 uViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;
            uniform vec3 uLightPosition;
            uniform vec3 uLightColor;
            uniform vec3 uAmbientColor;
            uniform float uAmbientIntensity;
            uniform float uAttenuationFactor;

            varying vec4 vColor;
            varying vec2 vTexCoord;
            varying vec3 vLighting;      // Pre-calculated lighting

            void main() {
                // Standard position calculation
                gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition;
                
                // Flat Shading Calculation:
                // Transform face normal
                vec3 faceNormal = normalize((uNormalMatrix * aNormal).xyz);
                
                // Transform centroid to world space
                vec4 worldCentroid = uModelMatrix * aCentroid;
                
                // Calculate light vector from centroid to light
                vec3 lightDir = uLightPosition - worldCentroid.xyz;
                float lightDistance = length(lightDir);
                lightDir = normalize(lightDir);
                
                // Calculate attenuation based on distance
                float attenuation = 1.0 / (1.0 + uAttenuationFactor * lightDistance + 0.01 * lightDistance * lightDistance);
                
                // Calculate diffuse factor using face normal and centroid-based light vector
                float diffuseFactor = max(dot(faceNormal, lightDir), 0.0) * attenuation;
                vec3 diffuse = uLightColor * diffuseFactor;
                
                // Calculate ambient component
                vec3 ambient = uAmbientColor * uAmbientIntensity;
                
                // Combine lighting (pass as a single value - key for flat shading)
                vLighting = ambient + diffuse;
                // --- End Flat Shading Calculation ---
                
                // Pass color and texture coordinates
                vColor = aColor;
                vTexCoord = aTexCoord;
            }
            `;

            const fragCode = `
                precision mediump float;
                
                varying vec4 vColor;
                varying vec2 vTexCoord;
                varying vec3 vLighting;      // Receive pre-calculated lighting
                
                uniform sampler2D uTexture;
                
                void main() {
                    // Get texture color
                    vec4 texColor = texture2D(uTexture, vTexCoord);
                    
                    // Apply the pre-calculated lighting to texture & vertex color
                    gl_FragColor = vec4(texColor.rgb * vColor.rgb * vLighting, 1.0);
            }
            `;
      </script>

      <script>
         // Create a canvas
         var canvas = document.getElementById('gl-canvas');
         var gl = canvas.getContext('webgl');
         
         if (!gl) {
            console.error("WebGL isn't available");
         }

         // Initialize GL
         glInit();
         
         // Create shader program
         var shaderprogram = createProgram(vertCode, fragCode);

         // Add this after your shader program creation:

         // Create a texture loader function
         function loadTexture(url) {
             const texture = gl.createTexture();
             gl.bindTexture(gl.TEXTURE_2D, texture);
             
             // Fill with a single pixel until image loads
             gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, 
                          new Uint8Array([255, 0, 0, 255]));
             
             // Load image
             const image = new Image();
             image.addEventListener("load", function() {
                 gl.bindTexture(gl.TEXTURE_2D, texture);
                 
                 gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                 
                 gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                 
                 // Set texture parameters
                 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                 
                 gl.generateMipmap(gl.TEXTURE_2D);
                 
                 // Force a redraw after texture loads
                 requestAnimationFrame(render);
             });
             
             image.addEventListener("error", function(e) {
                 console.error("Error loading texture:", e, url);
             });
             
             image.src = url;
             
             return texture;
         }

         // Load textures
         const brickTexture = loadTexture("textures/brick_texture.png");
         const grassTexture = loadTexture("textures/grass_texture.png");  
         const stoneTexture = loadTexture("textures/stone_texture.png"); 

         // Create objects array
         let sceneObjects = [];

         // Create the house
         let houseObject = house();
         let houseBuffer = initObject(houseObject, shaderprogram);
         houseBuffer.texture = brickTexture;
         houseBuffer.model = mat4.create();
         mat4.fromScaling(houseBuffer.model, [0.8, 0.8, 0.8]);
         houseBuffer.pulseSpeed = 0.6; // Moderate pulse speed for house
         houseBuffer.pulseOffset = 0; // Starting phase
         houseBuffer.baseScale = 0.8; // Base scale factor
         sceneObjects.push(houseBuffer);

         // Create the ground
         let groundObject = ground();
         let groundBuffer = initObject(groundObject, shaderprogram);
         groundBuffer.texture = grassTexture;
         groundBuffer.model = mat4.create();
         groundBuffer.pulseSpeed = 0; // Ground doesn't pulse
         groundBuffer.pulseOffset = 0;
         groundBuffer.baseScale = 1.0;
         sceneObjects.push(groundBuffer);

         // Create the path (curved version)
         let pathObject = curvedPath();
         let pathBuffer = initObject(pathObject, shaderprogram);
         pathBuffer.texture = stoneTexture;
         pathBuffer.model = mat4.create();
         pathBuffer.pulseSpeed = 0.0; // No pulse for path (new change)
         pathBuffer.pulseOffset = Math.PI / 2;
         pathBuffer.baseScale = 1.0;
         sceneObjects.push(pathBuffer);


         // Load tree textures
         const woodTexture = loadTexture("textures/wood_texture.png");
         const leafTexture = loadTexture("textures/leaf_texture.png");

         // Create trees
         const treePositions = [
             { x: 1.2, z: -0.4, scale: 0.9 },
             { x: -1.8, z: 0.8, scale: 0.8 },
             { x: 0.0, z: -1.5, scale: 1.1 }
         ];

         for (let i = 0; i < treePositions.length; i++) {
             const pos = treePositions[i];
             
             // Create tree trunk
             let trunkObject = treeTrunk();
             let trunkBuffer = initObject(trunkObject, shaderprogram);
             trunkBuffer.texture = woodTexture;
             trunkBuffer.model = mat4.create();
             
             // Position and scale the trunk
             mat4.fromScaling(trunkBuffer.model, [pos.scale, pos.scale, pos.scale]);
             mat4.translate(trunkBuffer.model, trunkBuffer.model, [pos.x, 0, pos.z]);
             
             trunkBuffer.pulseSpeed = 0.4 + i * 0.1; // Different speed for each tree
             trunkBuffer.pulseOffset = i * Math.PI / 3; // Different phase for each tree
             trunkBuffer.baseScale = pos.scale;
             
             sceneObjects.push(trunkBuffer);
             
             // Create tree crown
             let crownObject = treeCrown();
             let crownBuffer = initObject(crownObject, shaderprogram);
             crownBuffer.texture = leafTexture; // Use the leaf texture
             crownBuffer.model = mat4.create();
             
             // Position and scale the crown (same as trunk)
             mat4.fromScaling(crownBuffer.model, [pos.scale, pos.scale, pos.scale]);
             mat4.translate(crownBuffer.model, crownBuffer.model, [pos.x, 0, pos.z]);
             
             crownBuffer.pulseSpeed = 0.4 + i * 0.1; // Match trunk animation
             crownBuffer.pulseOffset = i * Math.PI / 3; // Match trunk animation
             crownBuffer.baseScale = pos.scale;
             
             sceneObjects.push(crownBuffer);
         }

         // Create a model matrix for the house
         let M_model = mat4.create();
         mat4.fromScaling(M_model, [0.5, 0.5, 0.5]); // Scale it down to fit in view (lvl 1)
         
         // Create a view matrix 
         // Trimetric projection: viewing object from 3 angles, none of which are equal
         let M_view = mat4.create();
         // Position camera at an angle to see all three dimensions
         mat4.lookAt(
            M_view,
            [2.5, 1.8, 3],            // Camera position (eye)
            [0, 0, 0],                // Target point (center)
            [0, 1, 0]                 // Up vector
         );
         
         // Create a perspective projection matrix
         let M_proj = mat4.create();
         mat4.perspective(
            M_proj,
            Math.PI/4,                 // Field of view (45 degrees)
            canvas.width/canvas.height, // Aspect ratio
            0.1,                      // Near clipping plane
            100                       // Far clipping plane
         );
         
         // Create a normal matrix
         let M_normal = mat4.create();
         let M_modelView = mat4.create();
         mat4.multiply(M_modelView, M_view, M_model);
         mat4.invert(M_normal, M_modelView);
         mat4.transpose(M_normal, M_normal);

         // Set uniform matrices
         gl.useProgram(shaderprogram);
         
         // Model matrix
         let modelLoc = gl.getUniformLocation(shaderprogram, "uModelMatrix");
         gl.uniformMatrix4fv(modelLoc, false, M_model);
         
         // View matrix
         let viewLoc = gl.getUniformLocation(shaderprogram, "uViewMatrix");
         gl.uniformMatrix4fv(viewLoc, false, M_view);
         
         // Projection matrix
         let projLoc = gl.getUniformLocation(shaderprogram, "uProjectionMatrix");
         gl.uniformMatrix4fv(projLoc, false, M_proj);
         
         // Normal matrix
         let normalLoc = gl.getUniformLocation(shaderprogram, "uNormalMatrix");
         gl.uniformMatrix4fv(normalLoc, false, M_normal);

         // Set up point light position and color
         const lightPosition = [2.0, 2.0, 2.0]; // Position light above and to the right of scene
         const lightColor = [1.0, 1.0, 0.9];    // Slightly warm light color
         const ambientColor = [0.4, 0.4, 0.45]; // Ambient light color
         const ambientIntensity = 0.4; // Ambient light intensity
         const attenuationFactor = 0.1; // Attenuation factor for distance-based lighting

         // Get uniform locations for light properties
         const lightPosLoc = gl.getUniformLocation(shaderprogram, "uLightPosition");
         const lightColorLoc = gl.getUniformLocation(shaderprogram, "uLightColor");

         // Set light uniforms
         gl.uniform3fv(lightPosLoc, lightPosition);
         gl.uniform3fv(lightColorLoc, lightColor);

         // Get locations for the ambient light properties
         const ambientColorLoc = gl.getUniformLocation(shaderprogram, "uAmbientColor");
         const ambientIntensityLoc = gl.getUniformLocation(shaderprogram, "uAmbientIntensity");
         const attenuationFactorLoc = gl.getUniformLocation(shaderprogram, "uAttenuationFactor");

         // Set initial values for the new uniforms
         gl.uniform3f(ambientColorLoc, ambientColor[0], ambientColor[1], ambientColor[2]); 
         gl.uniform1f(ambientIntensityLoc, ambientIntensity);            
         gl.uniform1f(attenuationFactorLoc, attenuationFactor);         

         // Set up texture uniform
         let texLoc = gl.getUniformLocation(shaderprogram, "uTexture");
         gl.uniform1i(texLoc, 0); // Use texture unit 0
         
         // Animation variables
         let angle = 0;
         let lastTime = null; // Use null instead of 0 to make it easier to check

         // Modify your existing render function to include the pulsing animation
         function render(currentTime) {
            // Convert to seconds first
            currentTime *= 0.001; 
            
            // Check if this is the first frame
            let deltaTime;
            if (lastTime === null) {
                deltaTime = 0.016; // Default to 60fps
            } else {
                deltaTime = currentTime - lastTime;
            }
            
            // Update lastTime after using it
            lastTime = currentTime;

            // Animate the light position - create a more interesting motion
            const lightX = 2.0 * Math.cos(currentTime * 0.5);
            const lightY = 1.5 + 0.5 * Math.sin(currentTime * 0.7); // Adding vertical motion
            const lightZ = 2.0 * Math.sin(currentTime * 0.5);
            gl.uniform3f(lightPosLoc, lightX, lightY, lightZ);
            
            // animating ambient intensity for cycle effects
            const cycleIntensity = 0.4 + 0.1 * Math.sin(currentTime * 0.1); // Slow ambient light cycle
            gl.uniform1f(ambientIntensityLoc, cycleIntensity);
            
            // Clear the canvas
            glInit();
            
            // Update the rotation angle
            angle += deltaTime * 0.5;
            
            // Draw each object
            for (let i = 0; i < sceneObjects.length; i++) {
                // Calculate pulsing scale factor using sine wave
                const pulseAmount = 0.1; // Max scale variation (10%)
                const pulseScale = sceneObjects[i].baseScale + 
                                   (Math.sin(currentTime * sceneObjects[i].pulseSpeed + 
                                    sceneObjects[i].pulseOffset) * pulseAmount);
                
                // Apply object's model matrix with both rotation and pulsing
                if (i === 0) { // House - animate with rotation and pulsing
                    mat4.identity(sceneObjects[i].model);
                    mat4.fromScaling(sceneObjects[i].model, [0.8 * pulseScale, 0.8 * pulseScale, 0.8 * pulseScale]);
                    mat4.rotateY(sceneObjects[i].model, sceneObjects[i].model, angle);
                } else if (i === 1 || i === 2) { // Ground and path - no pulsing
                    mat4.identity(sceneObjects[i].model);
                    mat4.fromScaling(sceneObjects[i].model, [1.0, 1.0, 1.0]);
                } else { // Trees - position and pulse
                    if (i >= 3) { // Tree objects start at index 3
                        // Calculate which tree this is (each tree has 2 parts)
                        const treeIndex = Math.floor((i - 3) / 2);
                        const isPart = (i - 3) % 2; // 0 for trunk, 1 for crown
                        
                        if (treeIndex < treePositions.length) {
                            const treePos = treePositions[treeIndex];
                            
                            // Apply pulsing and position for both trunk and crown
                            mat4.identity(sceneObjects[i].model);
                            mat4.fromScaling(sceneObjects[i].model, [
                                treePos.scale * pulseScale, 
                                treePos.scale * pulseScale, 
                                treePos.scale * pulseScale
                            ]);
                            mat4.translate(sceneObjects[i].model, sceneObjects[i].model, [treePos.x, 0, treePos.z]);
                        }
                    }
                }
                
                // Update normal matrix once per object
                let M_modelView = mat4.create();
                let M_normal = mat4.create();
                mat4.multiply(M_modelView, M_view, sceneObjects[i].model);
                mat4.invert(M_normal, M_modelView);
                mat4.transpose(M_normal, M_normal);
                
                // Update uniforms
                gl.uniformMatrix4fv(modelLoc, false, sceneObjects[i].model);
                gl.uniformMatrix4fv(normalLoc, false, M_normal);
                
                // Bind texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, sceneObjects[i].texture);
                
                // Draw the object
                drawObject(sceneObjects[i], shaderprogram);
            }
            
            // Request next frame
            requestAnimationFrame(render);
         }
         
         // Start animation
         requestAnimationFrame(render);
         
         // Debug info
        //  console.log("WebGL initialized");
        //  console.log("View Matrix:", M_view);
        //  console.log("Projection Matrix:", M_proj);
        //  console.log("Model Matrix:", M_model);
      </script>
   </body>
</html>