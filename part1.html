<!doctype html>

<html>
   <body>
      <canvas width = "800" height = "600" id = "gl-canvas">
        Sorry; your web browser does not support HTML5's canvas element.
      </canvas>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js" type="text/javascript"></script>
      <script>
         /**
          * This function initialises GL and the viewport.
          */
          function glInit() {
            // Initialise and clear viewport
            gl.clearColor(0.1, 0.1, 0.1, 0.9);
            gl.clearDepth(1.0);
            gl.viewport(0.0, 0.0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
         }

         /**
          * This function draws an object using the supplied shader program
          * 
          * @param   bufferObject   An object returned by initObject
          * @param   shaderprogram  a shader program returned by createProgram
          */
         function drawObject(bufferObject, shaderprogram) {
            gl.useProgram(shaderprogram);

            let vertex_buffer = bufferObject.vertex_buffer;
            let color_buffer = bufferObject.color_buffer;
            let normal_buffer = bufferObject.normal_buffer;
            let tex_buffer = bufferObject.tex_buffer;
            let centroid_buffer = bufferObject.centroid_buffer;
            let index_buffer = bufferObject.index_buffer;
            let number = bufferObject.numVertices;

            // Bind vertex buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
            let aPosition = gl.getAttribLocation(shaderprogram, "aPosition");
            if (aPosition !== -1) {
                gl.vertexAttribPointer(aPosition, 4, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(aPosition);
            }

            // Bind color buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
            let aColor = gl.getAttribLocation(shaderprogram, "aColor");
            if (aColor !== -1) {
                gl.vertexAttribPointer(aColor, 4, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(aColor);
            }

            // Bind normal buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, normal_buffer);
            let aNormal = gl.getAttribLocation(shaderprogram, "aNormal");
            if (aNormal !== -1) {
                gl.vertexAttribPointer(aNormal, 4, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(aNormal);
            }

            // Bind texture coordinate buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, tex_buffer);
            let aTexCoord = gl.getAttribLocation(shaderprogram, "aTexCoord");
            if (aTexCoord !== -1) {
                gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(aTexCoord);
            }

            // Add this for centroids
            gl.bindBuffer(gl.ARRAY_BUFFER, centroid_buffer);
            let aCentroid = gl.getAttribLocation(shaderprogram, "aCentroid");
            if (aCentroid !== -1) {
                gl.vertexAttribPointer(aCentroid, 4, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(aCentroid);
            }

            // Bind index buffer and draw
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
            gl.drawElements(gl.TRIANGLES, number, gl.UNSIGNED_SHORT, 0);
         }

         /**
          * This function initialises an object. It uploads all its arrays to the GPU
          * and records the references to each. We can then pass this object to drawObject
          * which will bind the arrays appropriately
          * 
          * @param   object         An object containing arrays for vertices, colors, normals, texcoords, and indices
          * @param   shaderprogram  a shader program returned by createProgram
          */
        function initObject(object, shaderprogram) {
            gl.useProgram(shaderprogram);

            // Vertices, colors and indices arrive in the form of 2D matrix objects for ease of manipulation
            // We need to flatten them and convert them to JS arrays before passing them to WebGL
            let vertices = object.vertices.flat();
            let colors = object.colors.flat();
            let indices = object.indices.flat();
            let normals = object.normals.flat();
            let texcoords = object.texcoords.flat();
            
            // Calculate centroids for each triangle for flat shading with point light
            let centroids = calculateCentroids(vertices, indices);
            
            // Create and store data into vertex buffer
            let vertex_buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            // Create and store data into color buffer
            let color_buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

            // Create and store data into normal buffer
            let normal_buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normal_buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

            // Create and store texture coordinates buffer
            let tex_buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, tex_buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
            
            // Add centroid buffer
            let centroid_buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, centroid_buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(centroids), gl.STATIC_DRAW);

            // Create and store data into index buffer
            let index_buffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            return { 
                vertex_buffer: vertex_buffer,
                color_buffer: color_buffer,
                normal_buffer: normal_buffer,
                tex_buffer: tex_buffer,
                centroid_buffer: centroid_buffer,
                index_buffer: index_buffer,
                numVertices: indices.length 
            };
        }

         /**
          * This function compiles the supplied vertex and fragment shaders into a program
          * 
          * @param   vertCode  Vertex shader code, written in GLSL
          * @param   fragCode  Fragment shader code, written in GLSL
          * 
          * @returns    Shader program
          */
         function createProgram(vertCode, fragCode) {
            // Compile and upload shader programs
            let vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, vertCode);
            gl.compileShader(vertShader);

            // Check for compilation errors
            if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
               console.error('Vertex shader compilation error: ' + gl.getShaderInfoLog(vertShader));
            }

            let fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, fragCode);
            gl.compileShader(fragShader);

            // Check for compilation errors
            if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
               console.error('Fragment shader compilation error: ' + gl.getShaderInfoLog(fragShader));
            }

            let shaderprogram = gl.createProgram();
            gl.attachShader(shaderprogram, vertShader);
            gl.attachShader(shaderprogram, fragShader);
            gl.linkProgram(shaderprogram);

            // Check for linking errors
            if (!gl.getProgramParameter(shaderprogram, gl.LINK_STATUS)) {
               console.error('Shader program linking error: ' + gl.getProgramInfoLog(shaderprogram));
            }

            gl.useProgram(shaderprogram);

            return shaderprogram;
         }

         /**
          * Calculates the centroid of each triangle for flat shading
          * @param {Array} vertices - Array of vertex positions
          * @param {Array} indices - Array of triangle indices
          * @returns {Array} - Array of centroids for each vertex in each triangle
          */
         function calculateCentroids(vertices, indices) {
            let centroids = [];
            
            // For each triangle
            for (let i = 0; i < indices.length; i += 3) {
                const idx1 = indices[i];
                const idx2 = indices[i+1];
                const idx3 = indices[i+2];
                
                // Get vertex positions from flattened array
                const v1x = vertices[idx1*4];
                const v1y = vertices[idx1*4+1];
                const v1z = vertices[idx1*4+2];
                
                const v2x = vertices[idx2*4];
                const v2y = vertices[idx2*4+1];
                const v2z = vertices[idx2*4+2];
                
                const v3x = vertices[idx3*4];
                const v3y = vertices[idx3*4+1];
                const v3z = vertices[idx3*4+2];
                
                // Calculate centroid of the triangle
                const centroidX = (v1x + v2x + v3x) / 3;
                const centroidY = (v1y + v2y + v3y) / 3;
                const centroidZ = (v1z + v2z + v3z) / 3;
                
                // Store the same centroid for each vertex of this triangle
                centroids.push(centroidX, centroidY, centroidZ, 1.0);
                centroids.push(centroidX, centroidY, centroidZ, 1.0);
                centroids.push(centroidX, centroidY, centroidZ, 1.0);
            }
            
            return centroids;
         }
      </script>
      <script>
         /**
          * Create a house shape with at least 8 faces
          * 
          * @returns    object consisting of vertices, colors, normals, texcoords, and indices
          */
         function house() {
            // Define and store geometry for a house
            // We'll create a house with a rectangular base and a triangular roof
            
            // Parameters for the house
            const width = 0.8;   // Width of the house
            const length = 1.0;  // Length of the house
            const height = 0.6;  // Height of the walls
            const roofHeight = 0.4; // Height of the roof peak from the top of the walls
            
            // Calculate half dimensions for use in vertex positions
            const w2 = width/2;
            const l2 = length/2;
            
            // Define vertices
            // Base/floor vertices (y = -height/2)
            // Roof peak is positioned at (0, height/2 + roofHeight, 0)
            
            let vertices = [
                // Base/floor (4 vertices)
                [-w2, -height/2, -l2, 1],  // 0: front-left
                [w2, -height/2, -l2, 1],   // 1: front-right
                [w2, -height/2, l2, 1],    // 2: back-right
                [-w2, -height/2, l2, 1],   // 3: back-left
                
                // Top of walls (4 vertices)
                [-w2, height/2, -l2, 1],   // 4: front-left-top
                [w2, height/2, -l2, 1],    // 5: front-right-top
                [w2, height/2, l2, 1],     // 6: back-right-top
                [-w2, height/2, l2, 1],    // 7: back-left-top
                
                // Roof peak
                [0, height/2 + roofHeight, 0, 1]  // 8: roof peak
            ];
           
            // Define the faces (triangles) - we need at least 8 faces in total
            let indices = [
                // Floor (2 triangles = 1 face)
                [0, 1, 2],
                [0, 2, 3],
                
                // Front wall (2 triangles = 1 face)
                [0, 4, 5],
                [0, 5, 1],
                
                // Right wall (2 triangles = 1 face)
                [1, 5, 6],
                [1, 6, 2],
                
                // Back wall (2 triangles = 1 face)
                [2, 6, 7],
                [2, 7, 3],
                
                // Left wall (2 triangles = 1 face)
                [3, 7, 4],
                [3, 4, 0],
                
                // Roof front (1 triangle = 1 face)
                [4, 8, 5],
                
                // Roof right (1 triangle = 1 face)
                [5, 8, 6],
                
                // Roof back (1 triangle = 1 face)
                [6, 8, 7],
                
                // Roof left (1 triangle = 1 face)
                [7, 8, 4]
            ];
            
            // Define colors (one per vertex)
            let colors = [
                [1.0, 1.0, 1.0, 1.0], // 0: floor front-left
                [1.0, 1.0, 1.0, 1.0], // 1: floor front-right
                [1.0, 1.0, 1.0, 1.0], // 2: floor back-right
                [1.0, 1.0, 1.0, 1.0], // 3: floor back-left
                
                [1.0, 1.0, 1.0, 1.0], // 4: wall top front-left
                [1.0, 1.0, 1.0, 1.0], // 5: wall top front-right
                [1.0, 1.0, 1.0, 1.0], // 6: wall top back-right
                [1.0, 1.0, 1.0, 1.0], // 7: wall top back-left
                
                [1.0, 1.0, 1.0, 1.0]  // 8: roof peak (white to let texture show)
            ];
            
            // Define normals - calculate proper face normals
            let normals = [
                [0, -1, 0, 0],   // 0: floor front-left (points down)
                [0, -1, 0, 0],   // 1: floor front-right
                [0, -1, 0, 0],   // 2: floor back-right
                [0, -1, 0, 0],   // 3: floor back-left
                
                [0, 0, -1, 0],   // 4: wall top front-left (points front)
                [0, 0, -1, 0],   // 5: wall top front-right
                [0, 0, 1, 0],    // 6: wall top back-right (points back)
                [0, 0, 1, 0],    // 7: wall top back-left
                
                [0, 1, 0, 0]     // 8: roof peak (points up)
            ];
            
            // Define texture coordinates - improved to properly map texture on faces
            let texcoords = [
                // Floor
                [0.0, 0.0],  // 0: floor front-left
                [1.0, 0.0],  // 1: floor front-right
                [1.0, 1.0],  // 2: floor back-right
                [0.0, 1.0],  // 3: floor back-left
                
                // Wall tops
                [0.0, 0.0],  // 4: wall top front-left
                [1.0, 0.0],  // 5: wall top front-right
                [1.0, 0.0],  // 6: wall top back-right
                [0.0, 0.0],  // 7: wall top back-left
                
                // Roof peak
                [0.5, 1.0]   // 8: roof peak
            ];
            
            return {
                vertices: vertices,
                colors: colors,
                indices: indices,
                normals: normals,
                texcoords: texcoords
            };
        }

        function ground() {
            // Define a large flat ground plane
            const size = 4.0;  // Size of the ground plane
            
            // Define vertices (a simple quad)
            let vertices = [
                [-size, -0.5, -size, 1],  // 0: front-left
                [size, -0.5, -size, 1],   // 1: front-right
                [size, -0.5, size, 1],    // 2: back-right
                [-size, -0.5, size, 1]    // 3: back-left
            ];
            
            // Define triangles
            let indices = [
                [0, 1, 2],  // First triangle
                [0, 2, 3]   // Second triangle
            ];
            
            // Define colors (white to let texture show fully)
            let colors = [
                [1.0, 1.0, 1.0, 1.0],
                [1.0, 1.0, 1.0, 1.0],
                [1.0, 1.0, 1.0, 1.0],
                [1.0, 1.0, 1.0, 1.0]
            ];
            
            // Define normals (pointing up)
            let normals = [
                [0, 1, 0, 0],
                [0, 1, 0, 0],
                [0, 1, 0, 0],
                [0, 1, 0, 0]
            ];
            
            // Define texture coordinates (tiled to make grass look better)
            let texcoords = [
                [0.0, 0.0],
                [4.0, 0.0],  // Repeat texture 4 times in X direction
                [4.0, 4.0],  // Repeat texture 4 times in both directions
                [0.0, 4.0]   // Repeat texture 4 times in Z direction
            ];
            
            return {
                vertices: vertices,
                colors: colors,
                indices: indices,
                normals: normals,
                texcoords: texcoords
            };
        }

        // Add this after your ground() function
        function path() {
            // Define a simple path from the edge toward the house
            const pathWidth = 0.5;
            const pathLength = 3.0;
            
            // Define vertices for a path starting from front (z-) direction
            // Set y-coordinate slightly above ground to prevent z-fighting
            let vertices = [
                // Left edge of path
                [-pathWidth/2, -0.49, -pathLength, 1],     // 0: far left
                [-pathWidth/2, -0.49, 0, 1],              // 1: near left
                
                // Right edge of path
                [pathWidth/2, -0.49, 0, 1],               // 2: near right
                [pathWidth/2, -0.49, -pathLength, 1]      // 3: far right
            ];
            
            // Define triangles
            let indices = [
                [0, 1, 2],  // First triangle
                [0, 2, 3]   // Second triangle
            ];
            
            // Define colors (white to let texture show fully)
            let colors = [
                [1.0, 1.0, 1.0, 1.0], // far left
                [1.0, 1.0, 1.0, 1.0], // near left
                [1.0, 1.0, 1.0, 1.0], // near right
                [1.0, 1.0, 1.0, 1.0]  // far right
            ];
            
            // Define normals (pointing up)
            let normals = [
                [0, 1, 0, 0], // far left
                [0, 1, 0, 0], // near left
                [0, 1, 0, 0], // near right
                [0, 1, 0, 0]  // far right
            ];
            
            // Define texture coordinates
            // Will repeat texture along the length of the path
            let texcoords = [
                [0.0, 0.0],  // far left
                [0.0, 3.0],  // near left (repeat texture 3 times along length)
                [1.0, 3.0],  // near right
                [1.0, 0.0]   // far right
            ];
            
            return {
                vertices: vertices,
                colors: colors,
                indices: indices,
                normals: normals,
                texcoords: texcoords
            };
        }

        // Add after the path() function
        function curvedPath() {
            const segments = 7;            // More segments for smoother curve
            const pathWidth = 0.3;         // Thinner path
            const pathLength = 0.6;        // Shorter segments for better control
            const curveAmount = 0.3;       // Increase curve amount
            const startDistance = -4.0;    // Start further away
            
            let vertices = [];
            let colors = [];
            let normals = [];
            let texcoords = [];
            let indices = [];
            
            let currentAngle = 0;
            let lastX = 0;
            let lastZ = startDistance; // Start further away
            
            for (let i = 0; i < segments; i++) {
                // Calculate new segment angle (gradually curving)
                currentAngle += curveAmount * (Math.sin(i/segments * Math.PI)); // Sine curve for natural path
                
                // Calculate next position based on previous segment
                let nextX = lastX + pathLength * Math.sin(currentAngle);
                let nextZ = lastZ + pathLength * Math.cos(currentAngle);
                
                // Stop adding segments if we get too close to the house (approximately at z=-0.5)
                if (nextZ > -0.6) {
                    break;
                }
                
                // Define four corners of this path segment
                let v0 = vertices.length / 4; // Number of vertices so far
                
                // Add vertices for this segment
                vertices.push(
                    lastX - pathWidth/2 * Math.cos(currentAngle), -0.49, lastZ + pathWidth/2 * Math.sin(currentAngle), 1,
                    lastX + pathWidth/2 * Math.cos(currentAngle), -0.49, lastZ - pathWidth/2 * Math.sin(currentAngle), 1,
                    nextX + pathWidth/2 * Math.cos(currentAngle), -0.49, nextZ - pathWidth/2 * Math.sin(currentAngle), 1,
                    nextX - pathWidth/2 * Math.cos(currentAngle), -0.49, nextZ + pathWidth/2 * Math.sin(currentAngle), 1
                );
                
                // Add colors
                for (let j = 0; j < 4; j++) {
                    colors.push(1.0, 1.0, 1.0, 1.0);
                    normals.push(0, 1, 0, 0);
                }
                
                // Add texture coordinates
                texcoords.push(
                    0.0, i,
                    1.0, i,
                    1.0, i+1,
                    0.0, i+1
                );
                
                // Add triangles (two per segment)
                indices.push(
                    v0, v0+1, v0+2,
                    v0, v0+2, v0+3
                );
                
                // Update for next segment
                lastX = nextX;
                lastZ = nextZ;
            }
            
            return {
                vertices: vertices,
                colors: colors,
                indices: indices, 
                normals: normals,
                texcoords: texcoords
            };
        }

        /**
         * Create a simple tree object consisting of a trunk and a cone-shaped crown
         */
        function tree() {
            // Tree parameters
            const trunkHeight = 0.6;
            const trunkRadius = 0.1;
            const crownHeight = 0.8;
            const crownRadius = 0.4;
            const segments = 8; // Number of segments for the cylindrical trunk and conical crown
            
            let vertices = [];
            let colors = [];
            let normals = [];
            let texcoords = [];
            let indices = [];
            
            // Create the tree trunk (cylinder)
            // Bottom center of trunk
            const trunkBottomY = -0.5; // Position at the same height as ground
            
            // Create the trunk vertices
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = trunkRadius * Math.cos(angle);
                const z = trunkRadius * Math.sin(angle);
                
                // Bottom vertex
                vertices.push([x, trunkBottomY, z, 1]);
                colors.push([0.6, 0.4, 0.2, 1.0]); // Brown for trunk
                normals.push([x, 0, z, 0]); // Normal pointing outward
                texcoords.push([i / segments, 0]);
                
                // Top vertex
                vertices.push([x, trunkBottomY + trunkHeight, z, 1]);
                colors.push([0.6, 0.4, 0.2, 1.0]); // Brown for trunk
                normals.push([x, 0, z, 0]); // Normal pointing outward
                texcoords.push([i / segments, 1]);
            }
            
            // Create trunk indices (triangles)
            for (let i = 0; i < segments; i++) {
                const idx = i * 2;
                
                // First triangle
                indices.push([idx, idx + 1, idx + 2]);
                
                // Second triangle
                indices.push([idx + 1, idx + 3, idx + 2]);
            }
            
            // Create the crown (cone)
            const crownBaseY = trunkBottomY + trunkHeight;
            const crownTopY = crownBaseY + crownHeight;
            
            // Crown base center
            const crownBaseCenterIdx = vertices.length;
            vertices.push([0, crownBaseY, 0, 1]);
            colors.push([0.0, 0.8, 0.0, 1.0]); // Green for crown
            normals.push([0, -1, 0, 0]); // Normal pointing down
            texcoords.push([0.5, 0.5]);
            
            // Crown top point
            const crownTopIdx = vertices.length;
            vertices.push([0, crownTopY, 0, 1]);
            colors.push([0.0, 0.8, 0.0, 1.0]); // Green for crown
            normals.push([0, 1, 0, 0]); // Normal pointing up
            texcoords.push([0.5, 0.5]);
            
            // Crown base circle
            const crownBaseStartIdx = vertices.length;
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = crownRadius * Math.cos(angle);
                const z = crownRadius * Math.sin(angle);
                
                // Base circle vertex
                vertices.push([x, crownBaseY, z, 1]);
                colors.push([0.0, 0.8, 0.0, 1.0]); // Green for crown
                
                // Calculate normal for cone surface (pointing outward and up)
                const nx = x;
                const nz = z;
                const normalLength = Math.sqrt(nx*nx + crownHeight*crownHeight + nz*nz);
                normals.push([nx/normalLength, crownHeight/normalLength, nz/normalLength, 0]);
                
                texcoords.push([i / segments, 0]);
            }
            
            // Create crown side triangles
            for (let i = 0; i < segments; i++) {
                const idx = crownBaseStartIdx + i;
                
                // Triangle from base to top
                indices.push([idx, idx + 1, crownTopIdx]);
                
                // Triangle for base circle (closing the bottom of the cone)
                indices.push([crownBaseCenterIdx, idx + 1, idx]);
            }
            
            return {
                vertices: vertices,
                colors: colors,
                indices: indices,
                normals: normals,
                texcoords: texcoords
            };
        }
      </script>

      <script>
         // GLSL shader code
         // Vertex shader will handle the transformations and coordinate calculations
         const vertCode = `
            attribute vec4 aPosition;
            attribute vec4 aColor;
            attribute vec4 aNormal;
            attribute vec2 aTexCoord;
            attribute vec4 aCentroid;

            uniform mat4 uModelMatrix;
            uniform mat4 uViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;
            uniform vec3 uLightPosition;

            varying vec4 vColor;
            varying vec2 vTexCoord;
            varying vec3 vNormal;
            varying vec3 vLightDir;
            varying float vLightDistance;
            
            void main() {
               // Position calculation
               gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition;
               
               // Calculate transformed centroid for flat shading with point light
               vec4 worldCentroid = uModelMatrix * aCentroid;
               
               // Transform normal
               vec4 transformedNormal = uNormalMatrix * aNormal;
               vNormal = transformedNormal.xyz;
               
               // Calculate light direction and distance for point light
               vLightDir = uLightPosition - worldCentroid.xyz;
               vLightDistance = length(vLightDir);
               
               // Pass color and texture coordinates
               vColor = aColor;
               vTexCoord = aTexCoord;
            }
         `;

         // Fragment shader will apply the texture and lighting calculations
         const fragCode = `
            precision mediump float;
            
            varying vec4 vColor;
            varying vec2 vTexCoord;
            varying vec3 vNormal;
            varying vec3 vLightDir;
            varying float vLightDistance;
            
            uniform sampler2D uTexture;
            uniform vec3 uLightColor;
            
            void main() {
               // Get texture color
               vec4 texColor = texture2D(uTexture, vTexCoord);
               
               // Ambient component
               vec3 ambient = vec3(0.3, 0.3, 0.3);
               
               // Normalize vectors
               vec3 normal = normalize(vNormal);
               vec3 lightDir = normalize(vLightDir);
               
               // Calculate diffuse with distance attenuation
               float attenuation = 1.0 / (1.0 + 0.1 * vLightDistance + 0.01 * vLightDistance * vLightDistance);
               float diffuseFactor = max(dot(normal, lightDir), 0.0) * attenuation;
               vec3 diffuse = uLightColor * diffuseFactor;
               
               // Combine lighting components
               vec3 lighting = ambient + diffuse;
               
               // Apply lighting to texture color
               gl_FragColor = vec4(texColor.rgb * vColor.rgb * lighting, 1.0);
            }
         `;
      </script>

      <script>
         // Create a canvas to paint on
         var canvas = document.getElementById('gl-canvas');
         var gl = canvas.getContext('webgl');
         
         if (!gl) {
            console.error("WebGL isn't available");
         }

         // Initialize GL
         glInit();
         
         // Create shader program
         var shaderprogram = createProgram(vertCode, fragCode);

         // Add this after your shader program creation:

         // Create a texture loader function
         function loadTexture(url) {
             const texture = gl.createTexture();
             gl.bindTexture(gl.TEXTURE_2D, texture);
             
             // Fill with a single pixel until image loads
             gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, 
                          new Uint8Array([255, 0, 0, 255]));
             
             // Load image
             const image = new Image();
             image.addEventListener("load", function() {
                 gl.bindTexture(gl.TEXTURE_2D, texture);
                 
                 // Move this line here - right before using the image
                 gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                 
                 gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                 
                 // Set texture parameters
                 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                 
                 gl.generateMipmap(gl.TEXTURE_2D);
                 
                 // Force a redraw after texture loads
                 requestAnimationFrame(render);
             });
             
             image.addEventListener("error", function(e) {
                 console.error("Error loading texture:", e, url);
             });
             
             image.src = url;
             
             return texture;
         }

         // Load textures
         const brickTexture = loadTexture("brick_texture.png");
         const grassTexture = loadTexture("grass_texture.png");  
         const stoneTexture = loadTexture("stone_texture.png"); 

         // Create objects array
         let sceneObjects = [];

         // Create the house
         let houseObject = house();
         let houseBuffer = initObject(houseObject, shaderprogram);
         houseBuffer.texture = brickTexture;
         houseBuffer.model = mat4.create();
         mat4.fromScaling(houseBuffer.model, [0.8, 0.8, 0.8]);
         houseBuffer.pulseSpeed = 0.6; // Moderate pulse speed for house
         houseBuffer.pulseOffset = 0; // Starting phase
         houseBuffer.baseScale = 0.8; // Base scale factor
         sceneObjects.push(houseBuffer);

         // Create the ground
         let groundObject = ground();
         let groundBuffer = initObject(groundObject, shaderprogram);
         groundBuffer.texture = grassTexture;
         groundBuffer.model = mat4.create();
         groundBuffer.pulseSpeed = 0; // Ground doesn't pulse
         groundBuffer.pulseOffset = 0;
         groundBuffer.baseScale = 1.0;
         sceneObjects.push(groundBuffer);

         // Create the path (curved version)
         let pathObject = curvedPath();
         let pathBuffer = initObject(pathObject, shaderprogram);
         pathBuffer.texture = stoneTexture;
         pathBuffer.model = mat4.create();
         pathBuffer.pulseSpeed = 0.2; // Slower pulse for path
         pathBuffer.pulseOffset = Math.PI / 2; // Out of phase with house
         pathBuffer.baseScale = 1.0;
         sceneObjects.push(pathBuffer);

         // Add this after your path creation code, before the render function setup

         // Load wood texture if not already loaded
         const woodTexture = loadTexture("wood_texture.png");

         // Create trees
         const treePositions = [
             { x: 1.2, z: -0.4, scale: 0.9 },
             { x: -1.8, z: 0.8, scale: 0.8 },
             { x: 0.0, z: -1.5, scale: 1.1 }
         ];

         for (let i = 0; i < treePositions.length; i++) {
             let treeObject = tree();
             let treeBuffer = initObject(treeObject, shaderprogram);
             treeBuffer.texture = woodTexture;
             treeBuffer.model = mat4.create();
             
             // Position and scale the tree
             const pos = treePositions[i];
             mat4.fromScaling(treeBuffer.model, [pos.scale, pos.scale, pos.scale]);
             mat4.translate(treeBuffer.model, treeBuffer.model, [pos.x, 0, pos.z]);
             
             treeBuffer.pulseSpeed = 0.4 + i * 0.1; // Different speed for each tree
             treeBuffer.pulseOffset = i * Math.PI / 3; // Different phase for each tree
             treeBuffer.baseScale = pos.scale;

             sceneObjects.push(treeBuffer);
         }

         // Create a model matrix for the house
         let M_model = mat4.create();
         mat4.fromScaling(M_model, [0.5, 0.5, 0.5]); // Scale it down to fit in view (lvl 1)
         
         // Create a view matrix (trimetric projection requires specific angles)
         // Trimetric projection: viewing object from 3 angles, none of which are equal
         let M_view = mat4.create();
         // Position camera at an angle to see all three dimensions
         mat4.lookAt(
            M_view,
            [2.5, 1.8, 3],            // Camera position (eye)
            [0, 0, 0],                // Target point (center)
            [0, 1, 0]                 // Up vector
         );
         
         // Create a perspective projection matrix
         let M_proj = mat4.create();
         mat4.perspective(
            M_proj,
            Math.PI/4,                 // Field of view (45 degrees)
            canvas.width/canvas.height, // Aspect ratio
            0.1,                      // Near clipping plane
            100                       // Far clipping plane
         );
         
         // Create a normal matrix
         let M_normal = mat4.create();
         let M_modelView = mat4.create();
         mat4.multiply(M_modelView, M_view, M_model);
         mat4.invert(M_normal, M_modelView);
         mat4.transpose(M_normal, M_normal);

         // Set uniform matrices
         gl.useProgram(shaderprogram);
         
         // Model matrix
         let modelLoc = gl.getUniformLocation(shaderprogram, "uModelMatrix");
         gl.uniformMatrix4fv(modelLoc, false, M_model);
         
         // View matrix
         let viewLoc = gl.getUniformLocation(shaderprogram, "uViewMatrix");
         gl.uniformMatrix4fv(viewLoc, false, M_view);
         
         // Projection matrix
         let projLoc = gl.getUniformLocation(shaderprogram, "uProjectionMatrix");
         gl.uniformMatrix4fv(projLoc, false, M_proj);
         
         // Normal matrix
         let normalLoc = gl.getUniformLocation(shaderprogram, "uNormalMatrix");
         gl.uniformMatrix4fv(normalLoc, false, M_normal);

         // Add after your shader uniform setup, before the animation starts

         // Set up point light position and color
         const lightPosition = [2.0, 2.0, 2.0]; // Position light above and to the right of scene
         const lightColor = [1.0, 1.0, 0.9];    // Slightly warm light color

         // Get uniform locations for light properties
         const lightPosLoc = gl.getUniformLocation(shaderprogram, "uLightPosition");
         const lightColorLoc = gl.getUniformLocation(shaderprogram, "uLightColor");

         // Set light uniforms
         gl.uniform3fv(lightPosLoc, lightPosition);
         gl.uniform3fv(lightColorLoc, lightColor);

         // Set up texture uniform
         let texLoc = gl.getUniformLocation(shaderprogram, "uTexture");
         gl.uniform1i(texLoc, 0); // Use texture unit 0
         
         // Animation variables
         let angle = 0;
         let lastTime = 0;

         // Modify your existing render function to include the pulsing animation
         function render(currentTime) {
            // Calculate time difference for smooth animation
            currentTime *= 0.001; // Convert to seconds
            const deltaTime = currentTime - lastTime || 0.016;
            lastTime = currentTime;

            // Keep the dynamic lighting
            const lightX = 2.0 * Math.cos(currentTime * 0.5);
            const lightZ = 2.0 * Math.sin(currentTime * 0.5);
            gl.uniform3f(lightPosLoc, lightX, 2.0, lightZ);
            
            // Clear the canvas
            glInit();
            
            // Update the rotation angle
            angle += deltaTime * 0.5;
            
            // Draw each object
            for (let i = 0; i < sceneObjects.length; i++) {
                // Calculate pulsing scale factor using sine wave
                const pulseAmount = 0.1; // Max scale variation (10%)
                const pulseScale = sceneObjects[i].baseScale + 
                                   (Math.sin(currentTime * sceneObjects[i].pulseSpeed + 
                                    sceneObjects[i].pulseOffset) * pulseAmount);
                
                // Apply object's model matrix with both rotation and pulsing
                if (i === 0) { // House - animate with rotation and pulsing
                    mat4.identity(sceneObjects[i].model);
                    mat4.fromScaling(sceneObjects[i].model, [0.8 * pulseScale, 0.8 * pulseScale, 0.8 * pulseScale]);
                    mat4.rotateY(sceneObjects[i].model, sceneObjects[i].model, angle);
                } else if (i === 1) { // Ground - no pulsing
                    mat4.identity(sceneObjects[i].model);
                    mat4.fromScaling(sceneObjects[i].model, [1.0, 1.0, 1.0]);
                } else if (i === 2) { // Path - horizontal pulsing only
                    mat4.identity(sceneObjects[i].model);
                    mat4.fromScaling(sceneObjects[i].model, [pulseScale, 1.0, pulseScale]);
                } else { // Trees - position and pulse
                    const treePos = treePositions[i-3];
                    mat4.identity(sceneObjects[i].model);
                    mat4.fromScaling(sceneObjects[i].model, [
                        treePos.scale * pulseScale, 
                        treePos.scale * pulseScale, 
                        treePos.scale * pulseScale
                    ]);
                    mat4.translate(sceneObjects[i].model, sceneObjects[i].model, [treePos.x, 0, treePos.z]);
                }
                
                // Update normal matrix
                let M_modelView = mat4.create();
                let M_normal = mat4.create();
                mat4.multiply(M_modelView, M_view, sceneObjects[i].model);
                mat4.invert(M_normal, M_modelView);
                mat4.transpose(M_normal, M_normal);
                
                // Update uniforms
                gl.uniformMatrix4fv(modelLoc, false, sceneObjects[i].model);
                gl.uniformMatrix4fv(normalLoc, false, M_normal);
                
                // Bind texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, sceneObjects[i].texture);
                
                // Draw the object
                drawObject(sceneObjects[i], shaderprogram);
            }
            
            // Request next frame
            requestAnimationFrame(render);
         }
         
         // Start animation
         requestAnimationFrame(render);
         
         // Debug info
         console.log("WebGL initialized");
         console.log("View Matrix:", M_view);
         console.log("Projection Matrix:", M_proj);
         console.log("Model Matrix:", M_model);
      </script>
   </body>
</html>